//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.1.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginRequest | undefined): Promise<AuthenticationResult>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addUser(body: AddUserRequest | undefined): Promise<AddUserResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(body: UpdateUserRequest | undefined): Promise<UpdateUserResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordRequest | undefined): Promise<ChangePasswordResponse>;
    /**
     * @return Success
     */
    getCards(): Promise<MyBets[]>;
    /**
     * @return Success
     */
    getCard(id: number): Promise<MyBet[]>;
    /**
     * @return Success
     */
    getCardExtended(id: number): Promise<MyBetExtende>;
    /**
     * @return Success
     */
    getActiveBets(): Promise<GetActivBetsResponse[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createMatchSelection(body: CreateMatchSelectionsRequest | undefined): Promise<CreateMatchSelectionsResponse>;
    /**
     * @param body (optional) 
     * @return Success
     */
    betOn(body: BetOnGame | undefined): Promise<BetOnGameResponse>;
    /**
     * @return Success
     */
    getBetResult(id: number): Promise<BetResultResponse>;
    /**
     * @return Success
     */
    getMatchSelectionsAll(): Promise<GetActiveMatchs[]>;
    /**
     * @return Success
     */
    getMatchSelections(id: number): Promise<GetActiveMatch>;
    /**
     * @return Success
     */
    getMatchTypesAll(): Promise<GetMatchTypes[]>;
    /**
     * @return Success
     */
    getMatchTypes(id: number): Promise<GetMatchTypes>;
    /**
     * @return Success
     */
    getOutcomes(): Promise<GetOutcomes[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateMatchResults(matchtypeId: number, matchSelectionId: number, body: UpdateBetResultRequest[] | undefined): Promise<UpdateBetResult[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateMatchResult(matchtypeId: number, matchSelectionId: number, body: UpdateBetResultRequest | undefined): Promise<UpdateBetResult>;
    /**
     * @return Success
     */
    getMatchResults(matchtypeId: number, matchSelectionId: number): Promise<GetMatchResult>;
    /**
     * @return Success
     */
    getTeams(): Promise<TeamResponse[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    addTeam(body: AddTeamCommand | undefined): Promise<TeamResponse>;
}

export class Client implements IClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginRequest | undefined, cancelToken?: CancelToken): Promise<AuthenticationResult> {
        let url_ = this.baseUrl + "/Auth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<AuthenticationResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticationResult.fromJS(resultData200);
            return Promise.resolve<AuthenticationResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthenticationResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUser(body: AddUserRequest | undefined, cancelToken?: CancelToken): Promise<AddUserResponse> {
        let url_ = this.baseUrl + "/Auth/add-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddUser(_response);
        });
    }

    protected processAddUser(response: AxiosResponse): Promise<AddUserResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AddUserResponse.fromJS(resultData200);
            return Promise.resolve<AddUserResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AddUserResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(body: UpdateUserRequest | undefined, cancelToken?: CancelToken): Promise<UpdateUserResponse> {
        let url_ = this.baseUrl + "/Auth/update-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: AxiosResponse): Promise<UpdateUserResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateUserResponse.fromJS(resultData200);
            return Promise.resolve<UpdateUserResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateUserResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordRequest | undefined, cancelToken?: CancelToken): Promise<ChangePasswordResponse> {
        let url_ = this.baseUrl + "/Auth/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: AxiosResponse): Promise<ChangePasswordResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ChangePasswordResponse.fromJS(resultData200);
            return Promise.resolve<ChangePasswordResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChangePasswordResponse>(null as any);
    }

    /**
     * @return Success
     */
    getCards( cancelToken?: CancelToken): Promise<MyBets[]> {
        let url_ = this.baseUrl + "/Bet/get-cards";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCards(_response);
        });
    }

    protected processGetCards(response: AxiosResponse): Promise<MyBets[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MyBets.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MyBets[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MyBets[]>(null as any);
    }

    /**
     * @return Success
     */
    getCard(id: number, cancelToken?: CancelToken): Promise<MyBet[]> {
        let url_ = this.baseUrl + "/Bet/get-card/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCard(_response);
        });
    }

    protected processGetCard(response: AxiosResponse): Promise<MyBet[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MyBet.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MyBet[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MyBet[]>(null as any);
    }

    /**
     * @return Success
     */
    getCardExtended(id: number, cancelToken?: CancelToken): Promise<MyBetExtende> {
        let url_ = this.baseUrl + "/Bet/get-card-extended/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCardExtended(_response);
        });
    }

    protected processGetCardExtended(response: AxiosResponse): Promise<MyBetExtende> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MyBetExtende.fromJS(resultData200);
            return Promise.resolve<MyBetExtende>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MyBetExtende>(null as any);
    }

    /**
     * @return Success
     */
    getActiveBets( cancelToken?: CancelToken): Promise<GetActivBetsResponse[]> {
        let url_ = this.baseUrl + "/Bet/get-active-bets";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetActiveBets(_response);
        });
    }

    protected processGetActiveBets(response: AxiosResponse): Promise<GetActivBetsResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetActivBetsResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<GetActivBetsResponse[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetActivBetsResponse[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMatchSelection(body: CreateMatchSelectionsRequest | undefined, cancelToken?: CancelToken): Promise<CreateMatchSelectionsResponse> {
        let url_ = this.baseUrl + "/Bet/create-match-selection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMatchSelection(_response);
        });
    }

    protected processCreateMatchSelection(response: AxiosResponse): Promise<CreateMatchSelectionsResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateMatchSelectionsResponse.fromJS(resultData200);
            return Promise.resolve<CreateMatchSelectionsResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateMatchSelectionsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    betOn(body: BetOnGame | undefined, cancelToken?: CancelToken): Promise<BetOnGameResponse> {
        let url_ = this.baseUrl + "/Bet/bet-on";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBetOn(_response);
        });
    }

    protected processBetOn(response: AxiosResponse): Promise<BetOnGameResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BetOnGameResponse.fromJS(resultData200);
            return Promise.resolve<BetOnGameResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BetOnGameResponse>(null as any);
    }

    /**
     * @return Success
     */
    getBetResult(id: number, cancelToken?: CancelToken): Promise<BetResultResponse> {
        let url_ = this.baseUrl + "/Bet/get-bet-result/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBetResult(_response);
        });
    }

    protected processGetBetResult(response: AxiosResponse): Promise<BetResultResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BetResultResponse.fromJS(resultData200);
            return Promise.resolve<BetResultResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BetResultResponse>(null as any);
    }

    /**
     * @return Success
     */
    getMatchSelectionsAll( cancelToken?: CancelToken): Promise<GetActiveMatchs[]> {
        let url_ = this.baseUrl + "/Bet/get-match-selections";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMatchSelectionsAll(_response);
        });
    }

    protected processGetMatchSelectionsAll(response: AxiosResponse): Promise<GetActiveMatchs[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetActiveMatchs.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<GetActiveMatchs[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetActiveMatchs[]>(null as any);
    }

    /**
     * @return Success
     */
    getMatchSelections(id: number, cancelToken?: CancelToken): Promise<GetActiveMatch> {
        let url_ = this.baseUrl + "/Bet/get-match-selections/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMatchSelections(_response);
        });
    }

    protected processGetMatchSelections(response: AxiosResponse): Promise<GetActiveMatch> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetActiveMatch.fromJS(resultData200);
            return Promise.resolve<GetActiveMatch>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetActiveMatch>(null as any);
    }

    /**
     * @return Success
     */
    getMatchTypesAll( cancelToken?: CancelToken): Promise<GetMatchTypes[]> {
        let url_ = this.baseUrl + "/Bet/get-match-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMatchTypesAll(_response);
        });
    }

    protected processGetMatchTypesAll(response: AxiosResponse): Promise<GetMatchTypes[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetMatchTypes.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<GetMatchTypes[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetMatchTypes[]>(null as any);
    }

    /**
     * @return Success
     */
    getMatchTypes(id: number, cancelToken?: CancelToken): Promise<GetMatchTypes> {
        let url_ = this.baseUrl + "/Bet/get-match-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMatchTypes(_response);
        });
    }

    protected processGetMatchTypes(response: AxiosResponse): Promise<GetMatchTypes> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetMatchTypes.fromJS(resultData200);
            return Promise.resolve<GetMatchTypes>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetMatchTypes>(null as any);
    }

    /**
     * @return Success
     */
    getOutcomes( cancelToken?: CancelToken): Promise<GetOutcomes[]> {
        let url_ = this.baseUrl + "/Bet/get-outcomes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOutcomes(_response);
        });
    }

    protected processGetOutcomes(response: AxiosResponse): Promise<GetOutcomes[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetOutcomes.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<GetOutcomes[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOutcomes[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMatchResults(matchtypeId: number, matchSelectionId: number, body: UpdateBetResultRequest[] | undefined, cancelToken?: CancelToken): Promise<UpdateBetResult[]> {
        let url_ = this.baseUrl + "/Bet/update-match-results/{matchtypeId}/{matchSelectionId}";
        if (matchtypeId === undefined || matchtypeId === null)
            throw new Error("The parameter 'matchtypeId' must be defined.");
        url_ = url_.replace("{matchtypeId}", encodeURIComponent("" + matchtypeId));
        if (matchSelectionId === undefined || matchSelectionId === null)
            throw new Error("The parameter 'matchSelectionId' must be defined.");
        url_ = url_.replace("{matchSelectionId}", encodeURIComponent("" + matchSelectionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMatchResults(_response);
        });
    }

    protected processUpdateMatchResults(response: AxiosResponse): Promise<UpdateBetResult[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UpdateBetResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<UpdateBetResult[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateBetResult[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMatchResult(matchtypeId: number, matchSelectionId: number, body: UpdateBetResultRequest | undefined, cancelToken?: CancelToken): Promise<UpdateBetResult> {
        let url_ = this.baseUrl + "/Bet/update-match-result/{matchtypeId}/{matchSelectionId}";
        if (matchtypeId === undefined || matchtypeId === null)
            throw new Error("The parameter 'matchtypeId' must be defined.");
        url_ = url_.replace("{matchtypeId}", encodeURIComponent("" + matchtypeId));
        if (matchSelectionId === undefined || matchSelectionId === null)
            throw new Error("The parameter 'matchSelectionId' must be defined.");
        url_ = url_.replace("{matchSelectionId}", encodeURIComponent("" + matchSelectionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMatchResult(_response);
        });
    }

    protected processUpdateMatchResult(response: AxiosResponse): Promise<UpdateBetResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateBetResult.fromJS(resultData200);
            return Promise.resolve<UpdateBetResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateBetResult>(null as any);
    }

    /**
     * @return Success
     */
    getMatchResults(matchtypeId: number, matchSelectionId: number, cancelToken?: CancelToken): Promise<GetMatchResult> {
        let url_ = this.baseUrl + "/Bet/get-match-results/{matchtypeId}/{matchSelectionId}";
        if (matchtypeId === undefined || matchtypeId === null)
            throw new Error("The parameter 'matchtypeId' must be defined.");
        url_ = url_.replace("{matchtypeId}", encodeURIComponent("" + matchtypeId));
        if (matchSelectionId === undefined || matchSelectionId === null)
            throw new Error("The parameter 'matchSelectionId' must be defined.");
        url_ = url_.replace("{matchSelectionId}", encodeURIComponent("" + matchSelectionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMatchResults(_response);
        });
    }

    protected processGetMatchResults(response: AxiosResponse): Promise<GetMatchResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetMatchResult.fromJS(resultData200);
            return Promise.resolve<GetMatchResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetMatchResult>(null as any);
    }

    /**
     * @return Success
     */
    getTeams( cancelToken?: CancelToken): Promise<TeamResponse[]> {
        let url_ = this.baseUrl + "/Team";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTeams(_response);
        });
    }

    protected processGetTeams(response: AxiosResponse): Promise<TeamResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TeamResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TeamResponse[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeamResponse[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addTeam(body: AddTeamCommand | undefined, cancelToken?: CancelToken): Promise<TeamResponse> {
        let url_ = this.baseUrl + "/Team";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddTeam(_response);
        });
    }

    protected processAddTeam(response: AxiosResponse): Promise<TeamResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TeamResponse.fromJS(resultData200);
            return Promise.resolve<TeamResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeamResponse>(null as any);
    }
}

export class AddTeamCommand implements IAddTeamCommand {
    name?: string | undefined;
    shortName?: string | undefined;

    constructor(data?: IAddTeamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.shortName = _data["shortName"];
        }
    }

    static fromJS(data: any): AddTeamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddTeamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        return data;
    }
}

export interface IAddTeamCommand {
    name?: string | undefined;
    shortName?: string | undefined;
}

export class AddUserRequest implements IAddUserRequest {
    username?: string | undefined;
    password?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;

    constructor(data?: IAddUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): AddUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        return data;
    }
}

export interface IAddUserRequest {
    username?: string | undefined;
    password?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
}

export class AddUserResponse implements IAddUserResponse {
    id?: number;
    statusName?: string | undefined;

    constructor(data?: IAddUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.statusName = _data["statusName"];
        }
    }

    static fromJS(data: any): AddUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["statusName"] = this.statusName;
        return data;
    }
}

export interface IAddUserResponse {
    id?: number;
    statusName?: string | undefined;
}

export class AuthenticationResult implements IAuthenticationResult {
    token?: string | undefined;
    userId?: number;

    constructor(data?: IAuthenticationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticationResult {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IAuthenticationResult {
    token?: string | undefined;
    userId?: number;
}

export class BetOnGame implements IBetOnGame {
    selectionId?: number;
    matchTypeId?: number;
    matches?: MatchRequest[] | undefined;
    amount?: number;

    constructor(data?: IBetOnGame) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.selectionId = _data["selectionId"];
            this.matchTypeId = _data["matchTypeId"];
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(MatchRequest.fromJS(item));
            }
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): BetOnGame {
        data = typeof data === 'object' ? data : {};
        let result = new BetOnGame();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["selectionId"] = this.selectionId;
        data["matchTypeId"] = this.matchTypeId;
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        data["amount"] = this.amount;
        return data;
    }
}

export interface IBetOnGame {
    selectionId?: number;
    matchTypeId?: number;
    matches?: MatchRequest[] | undefined;
    amount?: number;
}

export class BetOnGameResponse implements IBetOnGameResponse {
    statusName?: string | undefined;
    isSaved?: boolean;

    constructor(data?: IBetOnGameResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusName = _data["statusName"];
            this.isSaved = _data["isSaved"];
        }
    }

    static fromJS(data: any): BetOnGameResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BetOnGameResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusName"] = this.statusName;
        data["isSaved"] = this.isSaved;
        return data;
    }
}

export interface IBetOnGameResponse {
    statusName?: string | undefined;
    isSaved?: boolean;
}

export class BetResultResponse implements IBetResultResponse {
    matches?: MatchResponse[] | undefined;
    betAmount?: number;
    wonAmount?: number;
    totalWinCount?: number;
    cardId?: number;
    matchSelectionId?: number;
    matchTypeId?: number;

    constructor(data?: IBetResultResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(MatchResponse.fromJS(item));
            }
            this.betAmount = _data["betAmount"];
            this.wonAmount = _data["wonAmount"];
            this.totalWinCount = _data["totalWinCount"];
            this.cardId = _data["cardId"];
            this.matchSelectionId = _data["matchSelectionId"];
            this.matchTypeId = _data["matchTypeId"];
        }
    }

    static fromJS(data: any): BetResultResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BetResultResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        data["betAmount"] = this.betAmount;
        data["wonAmount"] = this.wonAmount;
        data["totalWinCount"] = this.totalWinCount;
        data["cardId"] = this.cardId;
        data["matchSelectionId"] = this.matchSelectionId;
        data["matchTypeId"] = this.matchTypeId;
        return data;
    }
}

export interface IBetResultResponse {
    matches?: MatchResponse[] | undefined;
    betAmount?: number;
    wonAmount?: number;
    totalWinCount?: number;
    cardId?: number;
    matchSelectionId?: number;
    matchTypeId?: number;
}

export class ChangePasswordRequest implements IChangePasswordRequest {
    password?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IChangePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordRequest {
    password?: string | undefined;
    newPassword?: string | undefined;
}

export class ChangePasswordResponse implements IChangePasswordResponse {
    id?: number;
    statusName?: string | undefined;

    constructor(data?: IChangePasswordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.statusName = _data["statusName"];
        }
    }

    static fromJS(data: any): ChangePasswordResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["statusName"] = this.statusName;
        return data;
    }
}

export interface IChangePasswordResponse {
    id?: number;
    statusName?: string | undefined;
}

export class CreateMatchSelectionsRequest implements ICreateMatchSelectionsRequest {
    name?: string | undefined;
    description?: string | undefined;
    activeUntil?: Date;
    matches?: number[] | undefined;
    matchesTypes?: number[] | undefined;

    constructor(data?: ICreateMatchSelectionsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.activeUntil = _data["activeUntil"] ? new Date(_data["activeUntil"].toString()) : <any>undefined;
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(item);
            }
            if (Array.isArray(_data["matchesTypes"])) {
                this.matchesTypes = [] as any;
                for (let item of _data["matchesTypes"])
                    this.matchesTypes!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateMatchSelectionsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMatchSelectionsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["activeUntil"] = this.activeUntil ? this.activeUntil.toISOString() : <any>undefined;
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item);
        }
        if (Array.isArray(this.matchesTypes)) {
            data["matchesTypes"] = [];
            for (let item of this.matchesTypes)
                data["matchesTypes"].push(item);
        }
        return data;
    }
}

export interface ICreateMatchSelectionsRequest {
    name?: string | undefined;
    description?: string | undefined;
    activeUntil?: Date;
    matches?: number[] | undefined;
    matchesTypes?: number[] | undefined;
}

export class CreateMatchSelectionsResponse implements ICreateMatchSelectionsResponse {
    matchSelectionId?: number;
    statusName?: string | undefined;
    isSaved?: boolean;

    constructor(data?: ICreateMatchSelectionsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchSelectionId = _data["matchSelectionId"];
            this.statusName = _data["statusName"];
            this.isSaved = _data["isSaved"];
        }
    }

    static fromJS(data: any): CreateMatchSelectionsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMatchSelectionsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchSelectionId"] = this.matchSelectionId;
        data["statusName"] = this.statusName;
        data["isSaved"] = this.isSaved;
        return data;
    }
}

export interface ICreateMatchSelectionsResponse {
    matchSelectionId?: number;
    statusName?: string | undefined;
    isSaved?: boolean;
}

export class GetActivBetsResponse implements IGetActivBetsResponse {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    typeName?: string | undefined;
    isEnabled?: boolean;

    constructor(data?: IGetActivBetsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.typeName = _data["typeName"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): GetActivBetsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivBetsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["typeName"] = this.typeName;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IGetActivBetsResponse {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    typeName?: string | undefined;
    isEnabled?: boolean;
}

export class GetActiveMatch implements IGetActiveMatch {
    matchSelectionId?: number;
    name?: string | undefined;
    description?: string | undefined;
    activeUntil?: Date;
    matches?: SelectionMatchResponse[] | undefined;

    constructor(data?: IGetActiveMatch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchSelectionId = _data["matchSelectionId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.activeUntil = _data["activeUntil"] ? new Date(_data["activeUntil"].toString()) : <any>undefined;
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(SelectionMatchResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetActiveMatch {
        data = typeof data === 'object' ? data : {};
        let result = new GetActiveMatch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchSelectionId"] = this.matchSelectionId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["activeUntil"] = this.activeUntil ? this.activeUntil.toISOString() : <any>undefined;
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetActiveMatch {
    matchSelectionId?: number;
    name?: string | undefined;
    description?: string | undefined;
    activeUntil?: Date;
    matches?: SelectionMatchResponse[] | undefined;
}

export class GetActiveMatchs implements IGetActiveMatchs {
    matchSelectionId?: number;
    name?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;

    constructor(data?: IGetActiveMatchs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchSelectionId = _data["matchSelectionId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): GetActiveMatchs {
        data = typeof data === 'object' ? data : {};
        let result = new GetActiveMatchs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchSelectionId"] = this.matchSelectionId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IGetActiveMatchs {
    matchSelectionId?: number;
    name?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
}

export class GetMatchResult implements IGetMatchResult {
    matchTypeId?: number;
    matchSelectionId?: number;
    matches?: MatchResult[] | undefined;

    constructor(data?: IGetMatchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchTypeId = _data["matchTypeId"];
            this.matchSelectionId = _data["matchSelectionId"];
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(MatchResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMatchResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetMatchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchTypeId"] = this.matchTypeId;
        data["matchSelectionId"] = this.matchSelectionId;
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetMatchResult {
    matchTypeId?: number;
    matchSelectionId?: number;
    matches?: MatchResult[] | undefined;
}

export class GetMatchTypes implements IGetMatchTypes {
    matchTypeId?: number;
    name?: string | undefined;

    constructor(data?: IGetMatchTypes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchTypeId = _data["matchTypeId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetMatchTypes {
        data = typeof data === 'object' ? data : {};
        let result = new GetMatchTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchTypeId"] = this.matchTypeId;
        data["name"] = this.name;
        return data;
    }
}

export interface IGetMatchTypes {
    matchTypeId?: number;
    name?: string | undefined;
}

export class GetOutcomes implements IGetOutcomes {
    id?: number;
    outcomeId?: number;
    name?: string | undefined;
    isEnabled?: boolean;

    constructor(data?: IGetOutcomes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.outcomeId = _data["outcomeId"];
            this.name = _data["name"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): GetOutcomes {
        data = typeof data === 'object' ? data : {};
        let result = new GetOutcomes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["outcomeId"] = this.outcomeId;
        data["name"] = this.name;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IGetOutcomes {
    id?: number;
    outcomeId?: number;
    name?: string | undefined;
    isEnabled?: boolean;
}

export class LoginRequest implements ILoginRequest {
    username?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    username?: string | undefined;
    password?: string | undefined;
}

export class MatchRequest implements IMatchRequest {
    matchId?: number;
    outcomeId?: number;

    constructor(data?: IMatchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchId = _data["matchId"];
            this.outcomeId = _data["outcomeId"];
        }
    }

    static fromJS(data: any): MatchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MatchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchId"] = this.matchId;
        data["outcomeId"] = this.outcomeId;
        return data;
    }
}

export interface IMatchRequest {
    matchId?: number;
    outcomeId?: number;
}

export class MatchResponse implements IMatchResponse {
    matchId?: number;
    outcomeId?: number;
    matchResultId?: number;
    matchResult?: string | undefined;

    constructor(data?: IMatchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchId = _data["matchId"];
            this.outcomeId = _data["outcomeId"];
            this.matchResultId = _data["matchResultId"];
            this.matchResult = _data["matchResult"];
        }
    }

    static fromJS(data: any): MatchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MatchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchId"] = this.matchId;
        data["outcomeId"] = this.outcomeId;
        data["matchResultId"] = this.matchResultId;
        data["matchResult"] = this.matchResult;
        return data;
    }
}

export interface IMatchResponse {
    matchId?: number;
    outcomeId?: number;
    matchResultId?: number;
    matchResult?: string | undefined;
}

export class MatchResult implements IMatchResult {
    matchId?: number;
    outcomeId?: number;

    constructor(data?: IMatchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchId = _data["matchId"];
            this.outcomeId = _data["outcomeId"];
        }
    }

    static fromJS(data: any): MatchResult {
        data = typeof data === 'object' ? data : {};
        let result = new MatchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchId"] = this.matchId;
        data["outcomeId"] = this.outcomeId;
        return data;
    }
}

export interface IMatchResult {
    matchId?: number;
    outcomeId?: number;
}

export class MyBet implements IMyBet {
    betCardId?: number;
    matchId?: number;
    homeTeam?: string | undefined;
    home?: string | undefined;
    awayTeam?: string | undefined;
    away?: string | undefined;
    matchType?: string | undefined;
    outcomeId?: number;
    outcomeName?: string | undefined;
    createdAt?: Date;
    matchSelectionId?: number;
    matchSelectionName?: string | undefined;
    matchSelectionDescription?: string | undefined;

    constructor(data?: IMyBet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.betCardId = _data["betCardId"];
            this.matchId = _data["matchId"];
            this.homeTeam = _data["homeTeam"];
            this.home = _data["home"];
            this.awayTeam = _data["awayTeam"];
            this.away = _data["away"];
            this.matchType = _data["matchType"];
            this.outcomeId = _data["outcomeId"];
            this.outcomeName = _data["outcomeName"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.matchSelectionId = _data["matchSelectionId"];
            this.matchSelectionName = _data["matchSelectionName"];
            this.matchSelectionDescription = _data["matchSelectionDescription"];
        }
    }

    static fromJS(data: any): MyBet {
        data = typeof data === 'object' ? data : {};
        let result = new MyBet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["betCardId"] = this.betCardId;
        data["matchId"] = this.matchId;
        data["homeTeam"] = this.homeTeam;
        data["home"] = this.home;
        data["awayTeam"] = this.awayTeam;
        data["away"] = this.away;
        data["matchType"] = this.matchType;
        data["outcomeId"] = this.outcomeId;
        data["outcomeName"] = this.outcomeName;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["matchSelectionId"] = this.matchSelectionId;
        data["matchSelectionName"] = this.matchSelectionName;
        data["matchSelectionDescription"] = this.matchSelectionDescription;
        return data;
    }
}

export interface IMyBet {
    betCardId?: number;
    matchId?: number;
    homeTeam?: string | undefined;
    home?: string | undefined;
    awayTeam?: string | undefined;
    away?: string | undefined;
    matchType?: string | undefined;
    outcomeId?: number;
    outcomeName?: string | undefined;
    createdAt?: Date;
    matchSelectionId?: number;
    matchSelectionName?: string | undefined;
    matchSelectionDescription?: string | undefined;
}

export class MyBetExtende implements IMyBetExtende {
    betCardId?: number;
    createdAt?: Date;
    matchSelectionId?: number;
    matchSelectionName?: string | undefined;
    matchSelectionDescription?: string | undefined;
    betAmount?: number;
    wonAmount?: number;
    totalWinCount?: number;
    matchType?: string | undefined;
    matches?: MyBetMatchExtend[] | undefined;

    constructor(data?: IMyBetExtende) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.betCardId = _data["betCardId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.matchSelectionId = _data["matchSelectionId"];
            this.matchSelectionName = _data["matchSelectionName"];
            this.matchSelectionDescription = _data["matchSelectionDescription"];
            this.betAmount = _data["betAmount"];
            this.wonAmount = _data["wonAmount"];
            this.totalWinCount = _data["totalWinCount"];
            this.matchType = _data["matchType"];
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(MyBetMatchExtend.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MyBetExtende {
        data = typeof data === 'object' ? data : {};
        let result = new MyBetExtende();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["betCardId"] = this.betCardId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["matchSelectionId"] = this.matchSelectionId;
        data["matchSelectionName"] = this.matchSelectionName;
        data["matchSelectionDescription"] = this.matchSelectionDescription;
        data["betAmount"] = this.betAmount;
        data["wonAmount"] = this.wonAmount;
        data["totalWinCount"] = this.totalWinCount;
        data["matchType"] = this.matchType;
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMyBetExtende {
    betCardId?: number;
    createdAt?: Date;
    matchSelectionId?: number;
    matchSelectionName?: string | undefined;
    matchSelectionDescription?: string | undefined;
    betAmount?: number;
    wonAmount?: number;
    totalWinCount?: number;
    matchType?: string | undefined;
    matches?: MyBetMatchExtend[] | undefined;
}

export class MyBetMatchExtend implements IMyBetMatchExtend {
    matchId?: number;
    homeTeam?: string | undefined;
    home?: string | undefined;
    awayTeam?: string | undefined;
    away?: string | undefined;
    outcomeId?: number;
    outcomeName?: string | undefined;
    matchResultId?: number;
    matchResult?: string | undefined;

    constructor(data?: IMyBetMatchExtend) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchId = _data["matchId"];
            this.homeTeam = _data["homeTeam"];
            this.home = _data["home"];
            this.awayTeam = _data["awayTeam"];
            this.away = _data["away"];
            this.outcomeId = _data["outcomeId"];
            this.outcomeName = _data["outcomeName"];
            this.matchResultId = _data["matchResultId"];
            this.matchResult = _data["matchResult"];
        }
    }

    static fromJS(data: any): MyBetMatchExtend {
        data = typeof data === 'object' ? data : {};
        let result = new MyBetMatchExtend();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchId"] = this.matchId;
        data["homeTeam"] = this.homeTeam;
        data["home"] = this.home;
        data["awayTeam"] = this.awayTeam;
        data["away"] = this.away;
        data["outcomeId"] = this.outcomeId;
        data["outcomeName"] = this.outcomeName;
        data["matchResultId"] = this.matchResultId;
        data["matchResult"] = this.matchResult;
        return data;
    }
}

export interface IMyBetMatchExtend {
    matchId?: number;
    homeTeam?: string | undefined;
    home?: string | undefined;
    awayTeam?: string | undefined;
    away?: string | undefined;
    outcomeId?: number;
    outcomeName?: string | undefined;
    matchResultId?: number;
    matchResult?: string | undefined;
}

export class MyBets implements IMyBets {
    betCardId?: number;
    matchSelectionId?: number;
    matchTypeId?: number;
    matchSelection?: string | undefined;
    matchType?: string | undefined;

    constructor(data?: IMyBets) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.betCardId = _data["betCardId"];
            this.matchSelectionId = _data["matchSelectionId"];
            this.matchTypeId = _data["matchTypeId"];
            this.matchSelection = _data["matchSelection"];
            this.matchType = _data["matchType"];
        }
    }

    static fromJS(data: any): MyBets {
        data = typeof data === 'object' ? data : {};
        let result = new MyBets();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["betCardId"] = this.betCardId;
        data["matchSelectionId"] = this.matchSelectionId;
        data["matchTypeId"] = this.matchTypeId;
        data["matchSelection"] = this.matchSelection;
        data["matchType"] = this.matchType;
        return data;
    }
}

export interface IMyBets {
    betCardId?: number;
    matchSelectionId?: number;
    matchTypeId?: number;
    matchSelection?: string | undefined;
    matchType?: string | undefined;
}

export class SelectionMatchResponse implements ISelectionMatchResponse {
    matchSelectionId?: number;
    matchId?: number;
    homeId?: number;
    home?: string | undefined;
    homeTeam?: string | undefined;
    awayId?: number;
    awayTeam?: string | undefined;
    away?: string | undefined;
    matchDate?: Date;

    constructor(data?: ISelectionMatchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchSelectionId = _data["matchSelectionId"];
            this.matchId = _data["matchId"];
            this.homeId = _data["homeId"];
            this.home = _data["home"];
            this.homeTeam = _data["homeTeam"];
            this.awayId = _data["awayId"];
            this.awayTeam = _data["awayTeam"];
            this.away = _data["away"];
            this.matchDate = _data["matchDate"] ? new Date(_data["matchDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectionMatchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SelectionMatchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchSelectionId"] = this.matchSelectionId;
        data["matchId"] = this.matchId;
        data["homeId"] = this.homeId;
        data["home"] = this.home;
        data["homeTeam"] = this.homeTeam;
        data["awayId"] = this.awayId;
        data["awayTeam"] = this.awayTeam;
        data["away"] = this.away;
        data["matchDate"] = this.matchDate ? this.matchDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISelectionMatchResponse {
    matchSelectionId?: number;
    matchId?: number;
    homeId?: number;
    home?: string | undefined;
    homeTeam?: string | undefined;
    awayId?: number;
    awayTeam?: string | undefined;
    away?: string | undefined;
    matchDate?: Date;
}

export class TeamResponse implements ITeamResponse {
    id?: number;
    name?: string | undefined;
    shortName?: string | undefined;

    constructor(data?: ITeamResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.shortName = _data["shortName"];
        }
    }

    static fromJS(data: any): TeamResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TeamResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        return data;
    }
}

export interface ITeamResponse {
    id?: number;
    name?: string | undefined;
    shortName?: string | undefined;
}

export class UpdateBetResult implements IUpdateBetResult {
    message?: string | undefined;

    constructor(data?: IUpdateBetResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): UpdateBetResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBetResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data;
    }
}

export interface IUpdateBetResult {
    message?: string | undefined;
}

export class UpdateBetResultRequest implements IUpdateBetResultRequest {
    matchId?: number;
    outcomeId?: number;

    constructor(data?: IUpdateBetResultRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchId = _data["matchId"];
            this.outcomeId = _data["outcomeId"];
        }
    }

    static fromJS(data: any): UpdateBetResultRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBetResultRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchId"] = this.matchId;
        data["outcomeId"] = this.outcomeId;
        return data;
    }
}

export interface IUpdateBetResultRequest {
    matchId?: number;
    outcomeId?: number;
}

export class UpdateUserRequest implements IUpdateUserRequest {
    id?: number;
    username?: string | undefined;
    password?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;

    constructor(data?: IUpdateUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UpdateUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        return data;
    }
}

export interface IUpdateUserRequest {
    id?: number;
    username?: string | undefined;
    password?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
}

export class UpdateUserResponse implements IUpdateUserResponse {
    id?: number;
    statusName?: string | undefined;

    constructor(data?: IUpdateUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.statusName = _data["statusName"];
        }
    }

    static fromJS(data: any): UpdateUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["statusName"] = this.statusName;
        return data;
    }
}

export interface IUpdateUserResponse {
    id?: number;
    statusName?: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}